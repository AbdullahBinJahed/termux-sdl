+++ diff -uN --ignore-matching-lines=RE --ignore-all-space --ignore-blank-lines --color=auto fftools/ffplay.c termux-sdl/app/src/main/cpp/ffplay/ffplay.c > /sdcard/ffplay.c.patch

--- fftools/ffplay.c	2021-03-09 12:03:24.920033847 +0800
+++ termux-sdl/app/src/main/cpp/ffplay/ffplay.c	2021-03-09 12:03:44.886702503 +0800
@@ -29,6 +29,8 @@
 #include <limits.h>
 #include <signal.h>
 #include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
 
 #include "libavutil/avstring.h"
 #include "libavutil/eval.h"
@@ -53,11 +55,15 @@
 # include "libavfilter/buffersrc.h"
 #endif
 
-#include <SDL.h>
-#include <SDL_thread.h>
+#include "SDL.h"
+#include "SDL_thread.h"
+#include "SDL_ttf.h"
+#include "SDL2_gfxPrimitives.h"
 
 #include "cmdutils.h"
 
+#include "log.h"
+
 #include <assert.h>
 
 const char program_name[] = "ffplay";
@@ -310,10 +316,8 @@
 static AVInputFormat *file_iformat;
 static const char *input_filename;
 static const char *window_title;
-static int default_width  = 640;
-static int default_height = 480;
-static int screen_width  = 0;
-static int screen_height = 0;
+//static int default_width, default_height;
+static int screen_width, screen_height;
 static int screen_left = SDL_WINDOWPOS_CENTERED;
 static int screen_top = SDL_WINDOWPOS_CENTERED;
 static int audio_disable;
@@ -351,6 +355,10 @@
 static const char **vfilters_list = NULL;
 static int nb_vfilters = 0;
 static char *afilters = NULL;
+static char vfilters[20] = {""};
+// playback speed
+static float af_speed = 0.0f;
+static float vf_speed = 0.0f;
 #endif
 static int autorotate = 1;
 static int find_stream_info = 1;
@@ -368,6 +376,7 @@
 static SDL_Renderer *renderer;
 static SDL_RendererInfo renderer_info = {0};
 static SDL_AudioDeviceID audio_dev;
+static SDL_DisplayMode mode;
 
 static const struct TextureFormatEntry {
     enum AVPixelFormat format;
@@ -395,10 +404,38 @@
                                  { AV_PIX_FMT_NONE,           SDL_PIXELFORMAT_UNKNOWN },
                              };
 
+
+// 这些方法实现在src/core/android/SDL_android.c
+
+// 设置亮度
+extern void SDL_AndroidSetBrightness(int);
+// 获取亮度
+extern int SDL_AndroidGetBrightness(void);
+
+// 设置音量
+extern void SDL_AndroidSetVolume(int);
+// 获取音量
+extern int SDL_AndroidGetVolume(void);
+
+// ==========================================
+
+
 #if CONFIG_AVFILTER
 static int opt_add_vfilter(void *optctx, const char *opt, const char *arg) {
     GROW_ARRAY(vfilters_list, nb_vfilters);
     vfilters_list[nb_vfilters - 1] = arg;
+
+    // 视频播放速度
+    if(arg != NULL && strcmp(vfilters, "") == 0) {
+        strncpy(vfilters, arg, strlen(arg));
+        if(strstr(vfilters, "setpts") != NULL) {
+            float vf_pts = 0;
+            sscanf(/*vfilters*/arg, "setpts=%f*PTS", &vf_pts);
+            vf_speed = 1.0f / vf_pts;
+            //LOGI(program_name, "vf_speed = %f\n", vf_speed);
+        }
+    }
+    //LOGI(program_name, "vfilters: %s\n", vfilters);
     return 0;
 }
 #endif
@@ -1262,10 +1299,218 @@
     av_free(is);
 }
 
+// ==================== draw progress =======================
+int start_x, start_y;
+int end_x, end_y;
+float curr_end_x;
+
+int line_width = 8;
+float progress = 0;
+// 拖动进度条标志
+bool is_seek_progress = false;
+
+static void draw_progress(SDL_Renderer *renderer) {
+    // 绘制进度条线
+    lineColor(renderer, start_x, start_y, end_x, end_y, 0xFFFFFFFF);
+    // 绘制当前进度 curr_end_x为当前播放进度条 结束的x坐标
+
+    curr_end_x = start_x + (end_x - start_x) * progress / 100;
+    if(curr_end_x > end_x)
+        curr_end_x = end_x;
+    thickLineRGBA(renderer, start_x, start_y,
+                  curr_end_x, end_y, line_width,
+                  0x66, 0xba, 0xff, 0xff);
+
+    // 绘制进度条小圆
+    filledCircleRGBA(renderer, curr_end_x, end_y, line_width * 2,
+                     0x66, 0xba, 0xff, 0xff);
+}
+
+// ==================== draw text =======================
+TTF_Font *font = NULL;
+SDL_Color text_color = { 0xff, 0xff, 0xff, 0};
+SDL_Rect text_rect;
+int font_size = 45;
+
+char total_duration[10] = {"00:00"};
+char curr_duration[10] = {"00:00"};
+
+char curr_volume[] = {"100"};
+char curr_bright[] = {"100"};
+
+
+int curr_time, total_time;
+float playback_speed = 1.0f;
+// 播放完成标志
+bool is_play_finished = false;
+// 音量改变标志
+bool is_changed_volume = false;
+// 亮度改变标志
+bool is_changed_bright = false;
+
+const char *font_path = "/system/fonts/DroidSans.ttf";
+
+// 文本位置
+enum text_position {
+    LEFT_TEXT, TOP_TEXT, RIGHT_TEXT, BOTTOM_TEXT, CENTER_TEXT, ANY_TEXT
+};
+
+// 初始化字体
+static void init_font(const char *font_path, int ptsize) {
+
+    /* Initialize the TTF library */
+    if(TTF_Init() < 0) {
+        LOGE(program_name, "Init TTF: %s\n", SDL_GetError());
+        return;
+    }
+
+    font = TTF_OpenFont(font_path, ptsize);
+
+    if(!font) {
+        LOGE(program_name, "Couldn't load TTF: %s\n", SDL_GetError());
+        return;
+    }
+
+    // 文本风格
+    TTF_SetFontStyle(font, TTF_STYLE_NORMAL);
+    TTF_SetFontHinting(font, TTF_HINTING_MONO);
+    TTF_SetFontOutline(font, 0);
+    TTF_SetFontKerning(font, 1);
+
+}
+
+// 绘制文本
+static void draw_text(SDL_Renderer *renderer, const char *text, int x, int y, int margin, int flag) {
+
+    // 消除锯齿感绘制文本
+    SDL_Surface *surface = TTF_RenderUTF8_Blended(font, text, text_color);
+    if(!surface) {
+        LOGE(program_name, "Surface: %s\n", SDL_GetError());
+    }
+
+    // 文本纹理
+    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
+    if(!texture) {
+        LOGE(program_name, "Texture: %s\n", SDL_GetError());
+    }
+
+    // 文本绘制区域
+    text_rect.x = x; // 绘制文本开始x坐标
+    text_rect.y = y; // 绘制文本开始y坐标
+    text_rect.w = surface->w;
+    text_rect.h = surface->h;
+
+    // 如果是绘制右边的文本，文本的开始x坐标需要重新计算
+    // 如果不预先获得文本宽度，则绘制的文本可能显示不全
+    // x = screen_width - surface->w(文本宽度)
+    if(flag == RIGHT_TEXT) {
+        text_rect.x = screen_width - text_rect.w - margin;
+    } else if(flag == BOTTOM_TEXT) {
+        text_rect.y = screen_height - text_rect.h - margin;
+    } else if(flag == CENTER_TEXT) {
+        text_rect.x = screen_width / 2 - text_rect.w / 2;
+        text_rect.y = screen_height / 2 - text_rect.h / 2;
+    }
+
+    SDL_FreeSurface(surface);
+    SDL_RenderCopy(renderer, texture, NULL, &text_rect);
+
+    SDL_DestroyTexture(texture);
+
+}
+
+// 格式化时间
+static void format_time(int seconds, char *time) {
+
+    int hh = seconds / 3600;
+    int mm = (seconds % 3600) / 60;
+    int ss = seconds % 60;
+
+    if(hh > 0) {
+        sprintf(time, "%02d:%02d:%02d", hh, mm, ss);
+    } else {
+        sprintf(time, "%02d:%02d", mm, ss);
+    }
+}
+
+// 获取播放速度，用于设置时间速度
+static void set_playback_speed() {
+
+    if(vf_speed != 0 && af_speed != 0) {
+        playback_speed = vf_speed >= af_speed ? vf_speed : af_speed;
+    } else {
+
+        if(vf_speed != 0)
+            playback_speed = vf_speed;
+        else if(af_speed != 0)
+            playback_speed = af_speed;
+    }
+}
+
+// SDL_ttf绘制当前时间显示文本
+static void set_curr_duration(int seconds) {
+    // 当前显示的时间 = 时间 * 播放速度
+    if(seconds > total_time)
+        seconds = total_time;
+    format_time(seconds, curr_duration);
+    // 计算当前进度值百分比
+    curr_time = seconds;
+    progress = (curr_time * 100) / total_time;
+}
+
+// SDL_ttf绘制总共的时间显示文本
+static void set_total_duration(int seconds) {
+
+    //int tns  = is->ic->duration / 1000000LL;
+    total_time = seconds;
+    format_time(seconds, total_duration);
+}
+
+
+// 绘制函数
+static void draw(SDL_Renderer *renderer) {
+    // 绘制左边文本(当前时间)
+    draw_text(renderer, curr_duration, 10, screen_height - 200, 0, LEFT_TEXT);
+    // 在绘制左边的文本时，设置进度条开始坐标
+    start_x = text_rect.x + text_rect.w + 30;
+    start_y = text_rect.y + text_rect.h / 2;
+
+    // 绘制右边文本(总共时间)
+    draw_text(renderer, total_duration, screen_width, screen_height - 200, 10, RIGHT_TEXT);
+    // 在绘制右边的文本时，设置进度条结束坐标
+    end_x = text_rect.x - 30;
+    end_y = text_rect.y + text_rect.h / 2;
+
+    // 显示当前的音量或者亮度值
+    if(is_changed_volume || is_changed_bright) {
+        font_size = 200;
+        TTF_SetFontSize(font, font_size);
+        if(is_changed_volume) {
+            draw_text(renderer, curr_volume, screen_width / 2, screen_height / 2, 0, CENTER_TEXT);
+        } else {
+            draw_text(renderer, curr_bright, screen_width / 2, screen_height / 2, 0, CENTER_TEXT);
+        }
+
+        font_size = 45;
+        TTF_SetFontSize(font, font_size);
+    }
+
+    // 绘制进度条
+    draw_progress(renderer);
+}
+
+
+
 static void do_exit(VideoState *is) {
     if (is) {
         stream_close(is);
     }
+
+    if(font) {
+        TTF_CloseFont(font);
+        TTF_Quit();
+    }
+
     if (renderer)
         SDL_DestroyRenderer(renderer);
     if (window)
@@ -1288,20 +1533,20 @@
 
 static void set_default_window_size(int width, int height, AVRational sar) {
     SDL_Rect rect;
-    int max_width  = screen_width  ? screen_width  : INT_MAX;
-    int max_height = screen_height ? screen_height : INT_MAX;
+    int max_width  = screen_width  ? screen_width  : mode.w/*INT_MAX*/;
+    int max_height = screen_height ? screen_height : mode.h/*INT_MAX*/;
     if (max_width == INT_MAX && max_height == INT_MAX)
         max_height = height;
     calculate_display_rect(&rect, 0, 0, max_width, max_height, width, height, sar);
-    default_width  = rect.w;
-    default_height = rect.h;
+    //default_width  = rect.w;
+    //default_height = rect.h;
 }
 
 static int video_open(VideoState *is) {
     int w,h;
 
-    w = screen_width ? screen_width : default_width;
-    h = screen_height ? screen_height : default_height;
+    w = screen_width ? screen_width : mode.w/*default_width*/;
+    h = screen_height ? screen_height : mode.h/*default_height*/;
 
     if (!window_title)
         window_title = input_filename;
@@ -1330,6 +1575,10 @@
         video_audio_display(is);
     else if (is->video_st)
         video_image_display(is);
+
+    // 开始绘制
+    draw(renderer);
+    // 刷新显示视频
     SDL_RenderPresent(renderer);
 }
 
@@ -1340,7 +1589,7 @@
         return c->pts;
     } else {
         double time = av_gettime_relative() / 1000000.0;
-        return c->pts_drift + time - (time - c->last_updated) * (1.0 - c->speed);
+        return c->pts_drift + time - (time - c->last_updated) * (1.0 - c->speed * 2);
     }
 }
 
@@ -1359,6 +1609,8 @@
 static void set_clock_speed(Clock *c, double speed) {
     set_clock(c, get_clock(c), c->serial);
     c->speed = speed;
+    LOGI(program_name, "speed = %f\n", speed);
+
 }
 
 static void init_clock(Clock *c, int *queue_serial) {
@@ -1658,6 +1911,14 @@
                 av_diff = get_master_clock(is) - get_clock(&is->vidclk);
             else if (is->audio_st)
                 av_diff = get_master_clock(is) - get_clock(&is->audclk);
+
+            // LOGI(program_name, "curr time: %7.2f\n", get_master_clock(is));
+            // 当前播放的时间 (clock * playback_speed)
+            // 当拖动进度条时，由calcu_curr_progress()方法设置当前时间，所有此处要判断is_seek_progress的值
+            if(!is_play_finished && !is_seek_progress)
+                set_curr_duration(((int)get_master_clock(is)) * playback_speed);
+
+
             av_log(NULL, AV_LOG_INFO,
                    "%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB f=%"PRId64"/%"PRId64"   \r",
                    get_master_clock(is),
@@ -1988,8 +2249,7 @@
 #if CONFIG_AVFILTER
             dec_channel_layout = get_valid_channel_layout(frame->channel_layout, frame->channels);
 
-            reconfigure =
-                cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.channels,
+            reconfigure = cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.channels,
                                frame->format, frame->channels)    ||
                 is->audio_filter_src.channel_layout != dec_channel_layout ||
                 is->audio_filter_src.freq           != frame->sample_rate ||
@@ -2010,6 +2270,16 @@
                 is->audio_filter_src.freq           = frame->sample_rate;
                 last_serial                         = is->auddec.pkt_serial;
 
+                // LOGI(program_name, "afilters: %s\n", afilters);
+                // 音频播放速度
+                if(afilters != NULL && strstr(afilters, "atempo") != NULL) {
+                    sscanf(afilters, "atempo=%f", &af_speed);
+                    LOGI(program_name, "af_speed: %f\n", af_speed);
+                }
+                // 设置播放速度
+                set_playback_speed();
+
+
                 if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
                     goto the_end;
             }
@@ -2268,7 +2538,7 @@
  * stored in is->audio_buf, with size in bytes given by the return
  * value.
  */
-static int audio_decode_frame(VideoState *is) {
+static int audio_resample_frame(VideoState *is) {
     int data_size, resampled_data_size;
     int64_t dec_channel_layout;
     av_unused double audio_clock0;
@@ -2388,7 +2658,7 @@
 
     while (len > 0) {
         if (is->audio_buf_index >= is->audio_buf_size) {
-            audio_size = audio_decode_frame(is);
+            audio_size = audio_resample_frame(is);
             if (audio_size < 0) {
                 /* if error, just output silence */
                 is->audio_buf = NULL;
@@ -2759,6 +3029,9 @@
         }
     }
 
+    // 获取总共的时长
+    set_total_duration(is->ic->duration / 1000000LL);
+
     if (ic->pb)
         ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use avio_feof() to test for the end
 
@@ -2941,7 +3215,17 @@
         if (!is->paused &&
                 (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&
                 (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {
+
+            // 播放完成
+            is_play_finished = true;
+            progress = 100;
+            strcpy(curr_duration, total_duration);
+
             if (loop != 1 && (!loop || --loop)) {
+                // 循环播放，重新设置当前时间
+                is_play_finished = false;
+                progress = 0;
+                strcpy(curr_duration, "00:00");
                 stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);
             } else if (autoexit) {
                 ret = AVERROR_EOF;
@@ -3193,15 +3477,216 @@
                                  AV_TIME_BASE_Q), 0, 0);
 }
 
+
+
+// ============================================================
+
+// 滑动方向
+enum move_direction {
+    MOVE_LEFT, MOVE_UP, MOVE_RIGHT, MOVE_DOWN
+};
+
+float old_x, old_y;
+int volume_level = 0;
+int bright_level = 0;
+
+// 水平方向
+static int check_horizontal_direction(float touch_x) {
+
+    if(touch_x < old_x) {
+        old_x = touch_x;
+        return MOVE_LEFT;
+    } else {
+        old_x = touch_x;
+        return MOVE_RIGHT;
+    }
+}
+
+// 垂直方向
+static int check_vertical_direction(float touch_y) {
+
+    if(touch_y < old_y) {
+        old_y = touch_y;
+        return MOVE_UP;
+    } else {
+        old_y = touch_y;
+        return MOVE_DOWN;
+    }
+}
+
+// 设置亮度
+//SDL_SetWindowBrightness(window, value) not support android
+static void set_brightness_level(float touch_x, float touch_y) {
+    if(touch_x >= 0 && touch_x < screen_width / 2) {
+        is_changed_bright = true;
+#ifdef __ANDROID__
+        if(bright_level == 0)
+            bright_level = SDL_AndroidGetBrightness();
+#else
+        bright_level = SDL_GetWindowBrightness(window);
+#endif
+        if(check_vertical_direction(touch_y) == MOVE_UP) {
+            // 向上滑动增加亮度
+            ++bright_level;
+            if(bright_level > 100) bright_level = 100;
+        } else {
+            // 向下滑动减少亮度
+            --bright_level;
+            // 最低亮度5
+            if(bright_level < 5) bright_level = 5;
+        }
+
+        sprintf(curr_bright, "%d", bright_level);
+
+#ifdef __ANDROID__
+        // 调用android方法设置亮度
+        SDL_AndroidSetBrightness(bright_level);
+#else
+        // 调用SDL2方法设置亮度
+        if(SDL_SetWindowBrightness(window, bright_level) < 0) {
+            LOGE(program_name, "%s\n", SDL_GetError());
+        }
+#endif
+    }
+}
+
+
+// 设置音量
+static void set_volume_level(VideoState *stream, float touch_x, float touch_y) {
+    if(touch_x > screen_width / 2 && touch_x <= screen_width) {
+        is_changed_volume = true;
+        //int volume_level = av_clip(stream->audio_volume, 0, 100);
+
+        // 当volume_level为0时，才调用SDL_AndroidGetVolume()方法
+        // SDL_AndroidGetVolume方法在[0..100]范围内，只会调用一次
+        if(volume_level == 0)
+            volume_level = SDL_AndroidGetVolume();
+
+        if(check_vertical_direction(touch_y) == MOVE_UP) {
+            // 向上滑动增加音量
+            ++volume_level;
+            if(volume_level > 100) volume_level = 100;
+        } else {
+            // 向下滑动减少音量
+            --volume_level;
+            if(volume_level < 0) volume_level = 0;
+        }
+
+        sprintf(curr_volume, "%d", volume_level);
+
+        // stream->audio_volume为音频音量，不是系统音量
+        // 比如当前系统音量为50，那么audio_volume音量的范围就为[0..50]
+        // 也就是说audio_volume的最大值，为当前的系统音量
+        if(stream->audio_volume != startup_volume)
+            stream->audio_volume = volume_level;
+
+        SDL_AndroidSetVolume(volume_level);
+    }
+}
+
+
+// 计算当前进度值
+static void calcu_curr_progress(float touch_x, float touch_y, double *frac) {
+    // 拖动进度条
+    if(touch_x >= start_x - 20 && touch_x <= end_x + 20
+            && touch_y >= start_y - 80 && touch_y <= end_y + 80) {
+        is_seek_progress = true;
+        is_play_finished = false;
+
+        curr_end_x = touch_x;
+        if(curr_end_x < start_x)
+            curr_end_x = start_x;
+        else if(curr_end_x > end_x)
+            curr_end_x = end_x;
+
+        *frac = ((curr_end_x - start_x)  / (end_x - start_x));
+        set_curr_duration((*frac) * total_time);
+    }
+}
+
+
+//typedef struct paramter {
+//    VideoState *stream;
+//    double frac;
+//} paramter;
+
+
+//static void seek_stream(void *data){
+//    struct paramter *params = (struct paramter*)data;
+//
+//    int64_t ts = params->frac * params->stream->ic->duration;
+//    if (params->stream->ic->start_time != AV_NOPTS_VALUE)
+//    ts += params->stream->ic->start_time;
+//    stream_seek(params->stream, ts, 0, 0);
+//}
+
+
+
 /* handle an event sent by the GUI */
 static void event_loop(VideoState *cur_stream) {
     SDL_Event event;
     double incr, pos, frac;
+    float touch_x, touch_y;
+    Uint32 curr_timestamp = 0;
+    Uint32 last_timestamp = 0;
+    //SDL_Thread *seek_thread = NULL;
 
     for (;;) {
         double x;
         refresh_loop_wait_event(cur_stream, &event);
         switch (event.type) {
+        case SDL_FINGERDOWN: // 触摸按下
+
+            touch_x = event.tfinger.x * screen_width;
+            touch_y = event.tfinger.y * screen_height;
+            old_x = touch_x;
+            old_y = touch_y;
+
+            curr_timestamp = event.tfinger.timestamp;
+            if(curr_timestamp - last_timestamp <= 300 && last_timestamp != 0) {
+                // 双击事件
+                toggle_pause(cur_stream);
+                last_timestamp = 0;
+            } else {
+                // 单击事件
+                last_timestamp = curr_timestamp;
+                // 计算当前进度值
+                calcu_curr_progress(touch_x, touch_y, &frac);
+            }
+            break;
+        case SDL_FINGERMOTION: // 触摸移动
+            touch_x = event.tfinger.x * screen_width;
+            touch_y = event.tfinger.y * screen_height;
+            // 计算当前进度值
+            if(!is_changed_bright && !is_changed_volume)
+                calcu_curr_progress(touch_x, touch_y, &frac);
+
+            // 没有拖动进度条，才允许改变亮度和音量
+            if(!is_seek_progress) {
+                // 设置屏幕亮度
+                set_brightness_level(touch_x, touch_y);
+                // 设置音量
+                set_volume_level(cur_stream, touch_x, touch_y);
+            }
+            break;
+        case SDL_FINGERUP: // 触摸抬起
+
+            if(is_seek_progress) {
+                // 创建线程进行seek, 因为在触摸滑动(SDL_FINGERMOTION)中进行seek操作会卡帧
+                //struct paramter params = {cur_stream, frac};
+                //seek_thread = SDL_CreateThread(seek_stream, "seek thread", (void*)&params);
+
+                int64_t ts = frac * cur_stream->ic->duration;
+                if(cur_stream->ic->start_time != AV_NOPTS_VALUE)
+                    ts += cur_stream->ic->start_time;
+                stream_seek(cur_stream, ts, 0, 0);
+            }
+
+            is_seek_progress = false;
+            is_changed_volume = false;
+            is_changed_bright = false;
+
+            break;
         case SDL_KEYDOWN:
             if (exit_on_keydown || event.key.keysym.sym == SDLK_ESCAPE || event.key.keysym.sym == SDLK_q) {
                 do_exit(cur_stream);
@@ -3663,7 +4148,15 @@
             flags |= SDL_WINDOW_BORDERLESS;
         else
             flags |= SDL_WINDOW_RESIZABLE;
-        window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, default_width, default_height, flags);
+
+        SDL_GetDesktopDisplayMode(0, &mode);
+        window = SDL_CreateWindow(input_filename,
+                                  SDL_WINDOWPOS_UNDEFINED,
+                                  SDL_WINDOWPOS_UNDEFINED,
+                                  /*default_width*/mode.w,
+                                  /*default_height*/mode.h,
+                                  flags | SDL_WINDOW_OPENGL);
+
         SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
         if (window) {
             renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
@@ -3682,6 +4175,10 @@
         }
     }
 
+    // 初始化显示时间字体文件
+    init_font(font_path, font_size);
+    SDL_AndroidLogPrint(LOG_INFO, program_name, "hello ffplay %d\n", font_size);
+
     is = stream_open(input_filename, file_iformat);
     if (!is) {
         av_log(NULL, AV_LOG_FATAL, "Failed to initialize VideoState!\n");
